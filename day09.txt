@getter / setter
접근제어자 -> ptivate : 캡슐화
객체의 필드를 객체의 내부뿐만 아니라 객체 밖에서도
마음껏 생성자를 통해서 사용할수 있게 되었다
필드를 보호하는 검증된 필드를 대입할수 있으며
외부에서 사용할 필드값을 정제한 후 값을 제공받는다

1)setter 메서드
생성자의 입력된 값을 사용하기전에 검증을 하고싶다 
필드 접근을 제한 할수 있다
2)getter 메서드
private한 필드를 객체 외부에서 값을 불러오기 위헤 구현하는 메서드다
메서드를 통해서만 값을 전달 받을수있다!

@생성자 : 오버로딩
객체를 생성할때 호출되어 객체의 초기화를 담당한다
특별한 메서드이고 라이브러리용 클래스는 모든 생성자를 가지고있다.!
+여러가지 객체를 마음껏 만든다
(클래스(클래스메소드 :자동 호출))->객체1,객체2.객체3)
:멤버 변수 /멤버 메소드 : 초기화 시킬수 있다!

1)생성자 호출위치
생성자는 클래스를 기반으로 객체를 생성할떄
객체의 초기화를 담당하는 역할이므로 객체를 생성할때
호출할수있다!

2)기본 생성자
모든 클래스에는 하나 이상 (오버로딩)의 생성자가 정의되어
있으면 클래스를 생성하면서 생성자를 선언하지 않았지만'
컴파일러가 기본 생성자를 자동으로 제공한다
인스턴스 초기화 작업이 요구되지 않는다면 생성자를 정의 하지 않아도 되고
컴파일러가 지공하는 기본 생성자를 사용하는것이 좋다.
(=자율적이지만 프로그래머가 세부적인 클래스를 설계할경우 사용된다 )

3)생성자 선언 이유
클래스 -->객체 초기화 -->메모리 (객체) : 멤버 변수 / 멤버 메서드
1.생성자의 이름은 클래스의 이름과 같다
2.생성자는 리턴 값이 없다.( 선택 X)
3.생성자도 오버로딩이 가능하고 여러개의 생성자를 만든다

@생성자 오버로딩

1)오버로딩
생성자를 다양한 매개변수의 형태로 선언할수 있으며 다양성을
제공할수있다. 오버로딩은 다형성과 상속에 영향을 끼친다

2) 생성자 오버로딩 종류
-매개변수의 초기화가 부족할경우 다양한 기본 생성자를 만들수있다
-매개변수의 개수가 똑같더라도 데이터형이 다르면 다른 생성자로 생성할수있다
-매개 변수가 같은 데이터 형이더라도 개수가 다른 생성자를 만들 경우
다른 생성자로 생성할수있다

3)this 사용방법
인스턴스 자기자신을 참조하는 변수라는 의미이다
클래스의 멤버변수를 참조한다는 의미해서 구분해서 사용
//기본생성 (int 매개변수명)
1.this.멤버변수 = 매개변수명;
2.this(필드1.필드2); //묶어서 한번에 사용가능
생성자, 같은 클래스의 다른 생성자를 호출할때 사용가능

4)this 특징
-같은 클래스안에서 생성자가 다른 생성자를 호출할때 사용
-다른 생성자 호출시 첫줄 사용
-코드 중복을 막는다.

5)생성자를 이용한 인스턴스 복사
참보 변수를 매개변수로 받아서 인스턴스 변수 값을 복사한다.
소스코드)
Car car = new car ();
Car car2 = new car(car); //참조변수로 객체를 받는다.

인스턴스를 생성할때 고려사랑
1)클래스 -어떤 클래스의 인스턴스를 생성하냐
2)생성자 - 선책한 클래스의 어떤 생성자로 인스턴스를 생성할것이냐

@상속 
부모의 클래스 ( 설게도 ) 자식에게 물려줘서 자식은
부모의 클래스와 (엄마 +아빠)와 나 자신 클래스를 함께 구현
할수있고 자식은 상속을 통해서 하나의 부모만 의존한다
상속 클래스 : 부모클래스/상위클래스/기반클래스
상속 받는 클래스 : 자식클래스/하위클래스/파생클래스

-구현방법
class A{ //부모 클래스

}
class B extends A { //자식 클래스 (B클래스는 의존한다)

}

1)super()메소드 (부모 기본 생성자)
부모 클래스의 생성자가 호출될떄 매개변수로 값을 전달 받아
부모 클래스의 필드들을 초기화 한다면
자식이 생성될때 부모 생성자를 넣어줘야한다
-기본생성자가 호출되면 부모기본생성자(super)가 호출
-부모 객체를 먼저 생성하고 자식 객체를 생성해야한다
